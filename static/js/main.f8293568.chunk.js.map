{"version":3,"sources":["../src sync ///translations//.*/.json$","../src sync ///on-startup/.(ts|tsx)$","../src sync //.css$","app/robot-widget/store/selectors.ts","app/robot-widget/index.tsx","app/common/cube/scramblers/full.ts","app/common/cube/libs/tools.ts","app/common/cube/libs/coordinates.ts","app/common/cube/libs/algorithms.ts","app/common/cube/solvers/five-side-solver.ts","app/common/cube/libs/cube.ts","app/common/cube/libs/move-table.ts","app/common/cube/libs/pruning-table.ts","app/common/cube/libs/search.ts","app/common/cube/libs/scramble-pieces.ts","app/common/cube/libs/gan-encoder.ts","app/common/array-reducers.ts","app/common/cube/solvers/cross-solver.ts","app/cube-preview/index.tsx","app/scramble-generator/index.tsx","app/common/cube/scramblers/oll.ts","app/common/cube/scramblers/pll.ts","app/main-screen/index.tsx","app/common/webpack.ts","translations/index.ts","serviceWorker.ts","index.tsx","app/common/store-reducers.ts","app/robot-widget/store/reducer.ts","app/robot-widget/store/on-startup.ts","app/robot-widget/store/actions.ts","app/common/store.ts"],"names":["map","webpackContext","req","id","webpackContextResolve","__webpack_require__","o","e","Error","code","keys","Object","resolve","module","exports","getRobotDevice","state","robot","device","getRobotServer","robotDevice","gatt","connected","RobotWidgetContainer","connect","registerRobot","unregisterRobot","props","className","IconButton","color","onClick","a","navigator","bluetooth","requestDevice","filters","namePrefix","optionalServices","server","getPrimaryService","deviceInfoService","getCharacteristic","modelCharacteristic","readValue","modelNumberValue","TextDecoder","decode","toUpperCase","addEventListener","console","log","BluetoothConnected","Bluetooth","cubeFaces","moveModifiers","faceEdges","D","L","B","U","R","F","generateScramble","total","cube","createCube","moveList","scramble","join","cubeHistory","twist","cubeStateStr","move","cubeFace","charAt","cubeFaceIdx","indexOf","rotationMultiplier","length","cubeState","split","prevCubeState","slice","faceletOffset","rotationOffset","edgeIdx","rotatedEdgeIdx","moves","currentState","Math","floor","random","newState","push","reset","splice","factorials","factorial","n","binomials","choose","k","s","nextRow","i","prev","getRandomInt","min","max","rotateParts","pieces","affected","updatedPieces","rotateLeft","left","right","original","rotateRight","getIndexFromOrientation","flipCount","sum","getOrientationFromIndex","index","numPieces","numFlips","orientation","parity","ori","getParity","j","getIndexFromPermutation","reversed","offset","position","edges","unshift","permutation","getPermutationFromIndex","size","base","binomial","powers","2","validateAlgorithm","algorithm","test","wideMoves","f","r","u","b","l","d","M","S","E","rotations","x","y","z","normalize","reduce","acc","axis","pow","concat","m","output","totalRotation","includes","outputMove","parseAlgorithm","returnTotalRotation","result","match","forEach","moveNum","URFToDLF","merge","formatAlgorithm","sequence","trim","Edges","Corners","edgeMoves","cornerMoves","permutationMove","moveIndex","updated","edgePermutationMove","cornerPermutationMove","edgeOrientationMove","moveNumber","cornerOrientationMove","allMoves","fiveSideMoves","MoveTable","settings","name","defaultIndex","solvedIndexes","table","this","doMove","cubieMove","getVector","getIndex","vector","createMoveHandler","createMoveTable","inverse","createEdgePermutationTable","getCorrectOrientations","numStates","indexes","target","every","piece","createEdgeOrientationTable","createCornerOrientationTable","PruningTable","moveTables","computePruningTable","value","obj","depth","done","permutations","arg","helper","arr","copy","cartesian","data","setPruningValue","find","check","getPruningValue","currentIndex","Search","createTables","initialized","pruningTables","moveTableNames","moveTableIndexes","sort","mappedTables","pruningTable","solution","lastMove","minimumDistance","power","distance","handleSolution","updatedIndexes","search","initialize","maxDepth","format","solutionRotation","reverse","inv","invertAlgorithm","formatted","phaseTwoMoves","phaseTwoSearch","getMergeCoord","FiveSideSearch","args","phaseTwoSolution","solve","FiveSideSolver","Array","isArray","solveCoordinates","eo","ep","co","cp","UPPER_FACE_POSITIONS","getOrientationFromEnabled","enabled","fill","getPermutationFromEnabled","adjustUpperFace","amount","getScrambleForPieces","permutationEdges","permutationCorners","orientationEdges","orientationCorners","adjustEdges","adjustCorners","moveMap","R2","D2","B2","L2","U2","getGANEncoding","Uint8Array","chunckSize","currentChunk","accumulator","currentValue","chunkReducer","CrossSearch","CubePreview","svgString","scrambleCode","Cube","CubePreviewCreator","asString","createScramblePreview","style","width","dangerouslySetInnerHTML","__html","ScrambleGeneratorContainer","robotServer","useState","scrambleType","setScrambleType","setScramble","FormControl","component","FormLabel","RadioGroup","row","aria-label","onChange","currentTarget","FormControlLabel","control","Radio","label","Button","variant","solveCode","crossSolver","ollScramble","pllScramble","Typography","disabled","Boolean","scrambleService","scrambleExecuteCharacteristic","writeValue","MainScreen","AppBar","Toolbar","importAll","requireContext","importCache","moduleKey","translations","require","messageMap","filepath","locale","pathParse","flattenTranslations","trans","key","currentKeys","language","messages","toLowerCase","isLocalhost","window","location","hostname","registerValidSW","swUrl","config","serviceWorker","register","then","registration","onupdatefound","installingWorker","installing","onstatechange","controller","onUpdate","onSuccess","catch","error","store","createStore","ReactDOM","render","document","getElementById","URL","process","href","origin","fetch","headers","response","contentType","get","status","ready","unregister","reload","checkValidServiceWorker","payloadReducer","action","payload","combineReducers","createReducer","builder","addCase","registerReducer","reducer","createAction","makeRestartable","rootSaga","reducerRegistry","sagaRegistry","saga","call","delay","spawn","sagaMiddleware","createSagaMiddleware","configureStore","middleware","run"],"mappings":"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","file":"static/js/main.f8293568.chunk.js","sourcesContent":["var map = {\n\t\"./translations/en-us.json\": 104\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = 103;","var map = {\n\t\"./app/robot-widget/store/on-startup.ts\": 111\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = 105;","var map = {\n\t\"./styles/defaults.css\": 107,\n\t\"./styles/utils.css\": 108,\n\t\"./styles/variables.css\": 109\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = 106;","import { ApplicationState } from \"app/common/store\";\nimport { RobotState } from \"app/robot-widget/store/types\";\n\nexport const getRobotDevice = (state: ApplicationState): RobotState[\"device\"] =>\n  state.robot.device;\n\nexport const getRobotServer = (\n  state: ApplicationState\n): BluetoothRemoteGATTServer | null => {\n  const robotDevice = getRobotDevice(state);\n  return robotDevice && robotDevice.gatt?.connected ? robotDevice.gatt : null;\n};\n","import React from \"react\";\nimport { connect } from \"react-redux\";\nimport { IconButton } from \"@material-ui/core\";\nimport { BluetoothConnected, Bluetooth } from \"@material-ui/icons\";\n\nimport { ApplicationState } from \"app/common/store\";\n\nimport { unregisterRobot, registerRobot } from \"app/robot-widget/store/actions\";\nimport { getRobotDevice } from \"app/robot-widget/store/selectors\";\nimport { RobotState } from \"app/robot-widget/store/types\";\n\nconst DEVICE_INFO_SERVICE_UUID = 0x180a;\nconst MODEL_NUMBER_SERVICE_UUID = 0x2a24;\n\nconst SCRAMBLE_SERVICE_UUID = 0xfff0;\n\ninterface RobotWidgetProps {\n  registerRobot: typeof registerRobot;\n  unregisterRobot: typeof unregisterRobot;\n  robotDevice?: RobotState[\"device\"];\n}\n\nexport function RobotWidget(props: RobotWidgetProps): JSX.Element {\n  // TODO pull callback into useCallback hook\n  // TODO pull async with dispatch into a saga\n  return (\n    <div className=\"flex-row\">\n      <IconButton\n        color=\"inherit\"\n        onClick={async () => {\n          try {\n            const device = await navigator.bluetooth.requestDevice({\n              filters: [{ namePrefix: \"GAN\" }],\n              optionalServices: [\n                SCRAMBLE_SERVICE_UUID,\n                DEVICE_INFO_SERVICE_UUID,\n              ],\n            });\n            const server = await device.gatt?.connect();\n            if (server) {\n              const deviceInfoService = await server.getPrimaryService(\n                DEVICE_INFO_SERVICE_UUID\n              );\n              const modelCharacteristic = await deviceInfoService.getCharacteristic(\n                MODEL_NUMBER_SERVICE_UUID\n              );\n              const modelNumberValue = await modelCharacteristic.readValue();\n              const modelNumber = new TextDecoder().decode(modelNumberValue);\n              if (modelNumber.toUpperCase() === \"GAN ROBOTCUBE\") {\n                device.addEventListener(\"gattserverdisconnected\", () =>\n                  props.unregisterRobot()\n                );\n                props.registerRobot(device);\n              } else {\n                //TODO show error message for connecting to wrong type of GAN device\n              }\n            }\n          } catch (error) {\n            console.log(error);\n          }\n        }}\n      >\n        {props.robotDevice ? <BluetoothConnected /> : <Bluetooth />}\n      </IconButton>\n    </div>\n  );\n}\n\nexport const RobotWidgetContainer = connect(\n  (state: ApplicationState) => ({\n    robotDevice: getRobotDevice(state),\n  }),\n  {\n    registerRobot,\n    unregisterRobot,\n  }\n)(RobotWidget);\n","const cubeFaces = [\"D\", \"L\", \"B\", \"U\", \"R\", \"F\"];\nconst moveModifiers = [\"\", \"2\", \"'\"];\n\n/*\n           +----------+\n           | 24 25 26 |\n           | 31  U 27 |\n           | 30 29 28 |\n+----------+----------+----------+----------+\n| 08 09 10 | 40 41 42 | 32 33 34 | 16 17 18 |\n| 15  L 11 | 47  F 43 | 39  R 35 | 23  B 19 |\n| 14 13 12 | 46 45 44 | 38 37 36 | 22 21 20 |\n+----------+----------+----------+----------+\n           | 00 01 02 |\n           | 07  D 03 |\n           | 06 05 04 |\n           +----------+\n*/\nconst faceEdges: Record<string, Array<number>> = {\n  D: [46, 45, 44, 38, 37, 36, 22, 21, 20, 14, 13, 12],\n  L: [24, 31, 30, 40, 47, 46, 0, 7, 6, 20, 19, 18],\n  B: [26, 25, 24, 8, 15, 14, 6, 5, 4, 36, 35, 34],\n  U: [18, 17, 16, 34, 33, 32, 42, 41, 40, 10, 9, 8],\n  R: [28, 27, 26, 16, 23, 22, 4, 3, 2, 44, 43, 42],\n  F: [30, 29, 28, 32, 39, 38, 2, 1, 0, 12, 11, 10],\n};\n\nexport function generateScramble(total = 26): string {\n  const cube = createCube();\n  const moveList = cube.scramble(total);\n  return moveList.join(\" \");\n}\n\nfunction createCube() {\n  const cubeHistory = [\"DDDDDDDDLLLLLLLLBBBBBBBBUUUUUUUURRRRRRRRFFFFFFFF\"];\n  const reset = () => cubeHistory.splice(1);\n  const twist = (cubeStateStr: string, move: string) => {\n    const cubeFace = move.charAt(0);\n    const cubeFaceIdx = cubeFaces.indexOf(cubeFace) * 8;\n    const rotationMultiplier =\n      move.length > 1 ? (move.charAt(1) === \"2\" ? 2 : 3) : 1;\n\n    const cubeState = cubeStateStr.split(\"\"); // convert to array in order to edit\n    const prevCubeState = cubeState.slice(0);\n\n    // Rotate the stickers on the face itself\n    for (let faceletOffset = 0; faceletOffset < 8; faceletOffset++) {\n      const rotationOffset = (faceletOffset + 6 * rotationMultiplier) % 8;\n      cubeState[cubeFaceIdx + faceletOffset] =\n        prevCubeState[cubeFaceIdx + rotationOffset];\n    }\n\n    // Rotate the adjacent stickers that are part of the same layer\n    for (let edgeIdx = 0; edgeIdx < 12; edgeIdx++) {\n      const rotatedEdgeIdx = (edgeIdx + 9 * rotationMultiplier) % 12;\n      cubeState[faceEdges[cubeFace][edgeIdx]] =\n        prevCubeState[faceEdges[cubeFace][rotatedEdgeIdx]];\n    }\n\n    return cubeState.join(\"\");\n  };\n  const scramble = (total = 26) => {\n    const moves = [];\n    let currentState = cubeHistory[cubeHistory.length - 1];\n\n    while (moves.length < total) {\n      // Generate a random move\n      const move =\n        cubeFaces[Math.floor(Math.random() * 6)] +\n        moveModifiers[Math.floor(Math.random() * 3)];\n      if (move.charAt(0) === \"F\") {\n        continue;\n      }\n      // Don't move the same face twice in a row\n      if (\n        moves.length > 0 &&\n        move.charAt(0) === moves[moves.length - 1].charAt(0)\n      ) {\n        continue;\n      }\n      // Avoid move sequences like \"R L R\", which is the same as \"R2 L\"\n      if (\n        moves.length > 1 &&\n        move.charAt(0) === moves[moves.length - 2].charAt(0) &&\n        moves[moves.length - 1].charAt(0) ===\n          cubeFaces[(cubeFaces.indexOf(move.charAt(0)) + 3) % 6]\n      ) {\n        continue;\n      }\n      const newState = twist(currentState, move);\n      if (cubeHistory.indexOf(newState) === -1) {\n        // If this state hasn't yet been encountered, save it and move on\n        moves.push(move);\n        cubeHistory.push(newState);\n        currentState = newState;\n      }\n    }\n    return moves;\n  };\n\n  return {\n    scramble,\n    reset,\n    twist,\n    currentState: cubeHistory[cubeHistory.length - 1],\n  };\n}\n","const factorials: number[] = [];\n\n/**\n * Calculates n factorial and attempts to cache\n * as much information as possible.\n */\nexport const factorial = (n: number): number => {\n  if (n === 0 || n === 1) {\n    return 1;\n  }\n\n  if (factorials[n] > 0) {\n    return factorials[n];\n  }\n\n  factorials[n] = factorial(n - 1) * n;\n\n  return factorials[n];\n};\n\nconst binomials: number[][] = [];\n\n/**\n * Calculates n choose k using cached binomial numbers.\n */\nexport const choose = (n: number, k: number): number => {\n  if (k > n) {\n    return 0;\n  }\n\n  while (n >= binomials.length) {\n    const s = binomials.length;\n    const nextRow = [];\n\n    nextRow[0] = 1;\n\n    for (let i = 1, prev = s - 1; i < s; i += 1) {\n      nextRow[i] = binomials[prev][i - 1] + binomials[prev][i];\n    }\n\n    nextRow[s] = 1;\n\n    binomials.push(nextRow);\n  }\n\n  return binomials[n][k];\n};\n\n/**\n * Cartesian product of a given nested array.\n */\nexport const cartesian = (arg: number[][]): number[][] => {\n  const result: number[][] = [];\n  const max = arg.length - 1;\n\n  const helper = (arr: number[], i: number) => {\n    for (let j = 0; j < arg[i].length; j += 1) {\n      const copy = arr.slice(0);\n\n      copy.push(arg[i][j]);\n\n      if (i === max) {\n        result.push(copy);\n      } else {\n        helper(copy, i + 1);\n      }\n    }\n  };\n\n  helper([], 0);\n\n  return result;\n};\n\n// Ger a random integer in the provided range, inclusive.\nexport const getRandomInt = (min: number, max: number): number =>\n  Math.floor(Math.random() * (max - min + 1)) + min;\n\nexport const permute = (n: number, r: number): number =>\n  factorial(n) / factorial(n - r);\n\n/**\n * Rotates the subarray containing the affected pieces\n * to the right by one.\n */\nexport const rotateParts = (pieces: number[], affected: number[]): number[] => {\n  const updatedPieces = pieces.slice(0);\n\n  updatedPieces[affected[0]] = pieces[affected[affected.length - 1]];\n\n  for (let i = 1; i < affected.length; i += 1) {\n    updatedPieces[affected[i]] = pieces[affected[i - 1]];\n  }\n\n  return updatedPieces;\n};\n","import { factorial, choose } from \"app/common/cube/libs/tools\";\n\n/**\n * In-place rotation of the subarray determined by the two\n * indexes left and right to the left by one.\n */\nconst rotateLeft = (pieces: number[], left: number, right: number): void => {\n  const original = pieces[left];\n\n  for (let i = left; i < right; i += 1) {\n    pieces[i] = pieces[i + 1];\n  }\n\n  pieces[right] = original;\n};\n\n/**\n * In-place rotation of the subarray determined by the two\n * indexes left and right to the right by one.\n */\nconst rotateRight = (pieces: number[], left: number, right: number): void => {\n  const original = pieces[right];\n\n  for (let i = right; i > left; i -= 1) {\n    pieces[i] = pieces[i - 1];\n  }\n\n  pieces[left] = original;\n};\n\n/**\n * Bijection which encodes a given orientation vector to an unique index.\n * The flip count is the number of ways in which a single piece in the\n * orientation vector may be oriented. For edges, this number is 2 flips,\n * and for corners there are 3 possible twists. Thus, edges are encoded\n * using a binary number system, and corners using a trinary number system.\n */\nexport const getIndexFromOrientation = (\n  pieces: number[],\n  flipCount: number\n): number => {\n  let sum = 0;\n\n  // Note that we do not include the last element in the vector here.\n  // This is because the orientation of the last piece if determined\n  // by the orientation of all the other pieces - when you rotate any\n  // axis on the cube, only an even number of pieces is affected.\n  for (let i = 0; i < pieces.length - 1; i += 1) {\n    sum = flipCount * sum + pieces[i];\n  }\n\n  return sum;\n};\n\n/**\n * Returns the original orientation vector given the number which\n * describes it, the number of pieces in the vector, and the number\n * of ways in which an individual piece may be oriented.\n */\nexport const getOrientationFromIndex = (\n  index: number,\n  numPieces: number,\n  numFlips: number\n): number[] => {\n  const orientation = [];\n\n  let parity = 0;\n\n  for (let i = numPieces - 2; i >= 0; i -= 1) {\n    const ori = index % numFlips;\n    index = Math.floor(index / numFlips);\n    orientation[i] = ori;\n    parity += ori;\n  }\n\n  // Restore the last piece based on the orientation of the other pieces.\n  orientation[numPieces - 1] = (numFlips - (parity % numFlips)) % numFlips;\n\n  return orientation;\n};\n\n/**\n * Each move on a cube perform an even number of swaps when considering\n * both edges and corner pieces at the same time. Thus, only half of all\n * cube states are reachable using legal moves. This also implies that\n * for a cube to be solvable, the parity of both corners and edges must\n * both be either even or odd. We use this to verify that a cube is\n * solvable when generating random state scrambles, and also to\n * describe the overall cube permutation using only 10 edges, 6 corners\n * and the parity of either the corners or the edges.\n */\nexport const getParity = (pieces: number[]): number => {\n  let sum = 0;\n\n  for (let i = pieces.length - 1; i > 0; i -= 1) {\n    for (let j = i - 1; j >= 0; j -= 1) {\n      if (pieces[j] > pieces[i]) {\n        sum += 1;\n      }\n    }\n  }\n\n  return sum % 2;\n};\n\n/**\n * Encodes the permutation of the affected pieces within the entire\n * permutation vector, by encoding both their position and then the\n * permutation of the affected pieces within the permutation vector\n * using a variable-base number system. If reversed is true, the\n * values are assigned right-to-left. This is used in the Kociemba\n * solver, so that 0 is used as the solved coordinate for the move\n * table describing the UD-slice edges.\n */\nexport const getIndexFromPermutation = (\n  pieces: number[],\n  affected: number[],\n  reversed = false\n): number => {\n  let offset = pieces.length - 1;\n  let position = 0;\n  let k = 1;\n\n  // Store the permutation of the subarray containing\n  // only the affected pieces.\n  const edges = [];\n\n  // Encode the position of the affected pieces in a number\n  // from 0 up to n choose k, where n is the number of pieces\n  // in the permutation vector and k is the number of affected pieces.\n  if (reversed) {\n    for (let n = pieces.length - 1; n >= 0; n -= 1) {\n      if (affected.indexOf(pieces[n]) >= 0) {\n        offset = Math.min(offset, pieces[n]);\n        position += choose(pieces.length - 1 - n, k);\n        edges.unshift(pieces[n]);\n        k += 1;\n      }\n    }\n  } else {\n    for (let n = 0; n < pieces.length; n += 1) {\n      if (affected.indexOf(pieces[n]) >= 0) {\n        offset = Math.min(offset, pieces[n]);\n        position += choose(n, k);\n        edges.push(pieces[n]);\n        k += 1;\n      }\n    }\n  }\n\n  let permutation = 0;\n\n  // Encode the position of the subarray as a number from 0 and up\n  // to n factorial, where n is the number of affected pieces.\n  for (let i = edges.length - 1; i > 0; i -= 1) {\n    let s = 0;\n\n    while (edges[i] !== affected[i]) {\n      rotateLeft(edges, 0, i);\n      s += 1;\n    }\n\n    permutation = (i + 1) * permutation + s;\n  }\n\n  // Encode both the position and the permutation\n  // as a number using a variable base.\n  return factorial(affected.length) * position + permutation;\n};\n\n/**\n * Restores the permutation described by an index, number of affected\n * pieces and the permutation vector size. If reversed is true, the\n * indexes have been assigned right-to-left.\n */\nexport const getPermutationFromIndex = (\n  index: number,\n  affected: number[],\n  size: number,\n  reversed = false\n): number[] => {\n  const base = factorial(affected.length);\n\n  let position = Math.floor(index / base);\n  let permutation = index % base;\n\n  const pieces = [];\n\n  for (let i = 0; i < size; i += 1) {\n    pieces.push(-1);\n  }\n\n  for (let i = 1; i < affected.length; i += 1) {\n    let s = permutation % (i + 1);\n    permutation = Math.floor(permutation / (i + 1));\n\n    while (s > 0) {\n      rotateRight(affected, 0, i);\n      s -= 1;\n    }\n  }\n\n  let k = affected.length - 1;\n\n  if (reversed) {\n    for (let n = 0; n < size; n += 1) {\n      const binomial = choose(size - 1 - n, k + 1);\n\n      if (position - binomial >= 0) {\n        pieces[n] = affected[affected.length - 1 - k];\n        position -= binomial;\n        k -= 1;\n      }\n    }\n  } else {\n    for (let n = size - 1; n >= 0; n -= 1) {\n      const binomial = choose(n, k + 1);\n\n      if (position - binomial >= 0) {\n        pieces[n] = affected[k];\n        position -= binomial;\n        k -= 1;\n      }\n    }\n  }\n\n  return pieces;\n};\n","// Numeric representation of the different powers of moves.\nconst powers: Record<string, number> = {\n  \"\": 0,\n  2: 1,\n  \"'\": 2,\n};\n\n/**\n * Check whether or not we are able to parse the given algorithm string.\n */\nconst validateAlgorithm = (algorithm: string): boolean =>\n  /^([FRUBLDfrubldxyzMSE][2']?\\s*)+$/.test(algorithm);\n\n// Map single-power wide moves to a rotation + moves.\nconst wideMoves: Record<string, string[]> = {\n  f: [\"z\", \"B\"],\n  r: [\"x\", \"L\"],\n  u: [\"y\", \"D\"],\n  b: [\"z'\", \"F\"],\n  l: [\"x'\", \"R\"],\n  d: [\"y'\", \"U\"],\n  M: [\"x'\", \"R\", \"L'\"],\n  S: [\"z\", \"F'\", \"B\"],\n  E: [\"y'\", \"U\", \"D'\"],\n};\n\n// Specifies the translation of FRUBLD as performed by rotations.\nconst rotations: Record<string, string> = {\n  x: \"DRFULB\",\n  y: \"RBULFD\",\n  z: \"FULBDR\",\n};\n\n/**\n * Strip rotations and wide moves from an algorithm. Returns\n * an array of moves as strings.\n */\nconst normalize = (moves: string[]) => {\n  // Replace wide moves with rotations + moves.\n  moves = moves.reduce((acc: string[], move: string) => {\n    const axis: keyof typeof wideMoves = move.charAt(0);\n    const pow = move.charAt(1);\n\n    if (wideMoves[axis]) {\n      return acc.concat(wideMoves[axis].map((m) => m + pow));\n    }\n\n    return acc.concat(move);\n  }, []);\n\n  let output: string[] = [];\n\n  // We store all rotations that were encountered, to map the\n  // solution to the same final rotation as the scramble.\n  const totalRotation: string[] = [];\n\n  // Remove rotations by mapping all moves to the right of the rotation.\n  for (let i = moves.length - 1; i >= 0; i -= 1) {\n    const axis = moves[i].charAt(0);\n    const pow = powers[moves[i].charAt(1)];\n\n    if (\"xyz\".includes(axis)) {\n      totalRotation.unshift(moves[i]);\n\n      for (let j = 0; j <= pow; j += 1) {\n        output = output.map(\n          (outputMove) =>\n            rotations[axis][\"FRUBLD\".indexOf(outputMove[0])] +\n            outputMove.charAt(1)\n        );\n      }\n    } else {\n      output.unshift(moves[i]);\n    }\n  }\n\n  return [output, totalRotation];\n};\n\n/**\n * Parses a scramble, returning an array of integers describing the moves.\n */\nexport function parseAlgorithm(algorithm: string): number[];\nexport function parseAlgorithm(\n  algorithm: string,\n  returnTotalRotation: boolean\n): [number[], string[]];\nexport function parseAlgorithm(\n  algorithm: string,\n  returnTotalRotation = false\n): number[] | [number[], string[]] {\n  if (!validateAlgorithm(algorithm)) {\n    throw new Error(\"Invalid algorithm provided to algorithm parser\");\n  }\n\n  const result: number[] = [];\n\n  const [moves, totalRotation] = normalize(\n    algorithm.match(/[FRUBLDfrubldxyzMSE][2']?/g) || []\n  );\n\n  moves.forEach((move) => {\n    const moveNum = \"FRUBLD\".indexOf(move.charAt(0));\n    const pow = powers[move.charAt(1)];\n    result.push(moveNum * 3 + pow);\n  });\n\n  if (returnTotalRotation) {\n    return [result, totalRotation];\n  }\n\n  return result;\n}\n\n/**\n * Computes the inverse of a given algorithm. Rotations are supported.\n */\nexport const invertAlgorithm = (algorithm: string): string => {\n  if (!validateAlgorithm(algorithm)) {\n    throw new Error(\"Invalid algorithm provided to algorithm parser\");\n  }\n\n  const moves = algorithm.match(/[FRUBLDfrubldxyzMSE][2']?/g) || [];\n\n  const inverted = moves.reverse().map((move) => {\n    const axis = move.charAt(0);\n    const pow = powers[move.charAt(1)];\n    const inv = pow - 2 * (pow % 3) + 2;\n\n    if (inv === 1) {\n      return `${axis}2`;\n    }\n\n    if (inv === 2) {\n      return `${axis}'`;\n    }\n\n    return axis;\n  });\n\n  return inverted.join(\" \");\n};\n\n/**\n * Convert an array of integers to a human-readable representation.\n */\nexport const formatAlgorithm = (moves: number[]): string => {\n  let sequence = \"\";\n\n  moves.forEach((move) => {\n    sequence += \" \";\n    sequence += \"FRUBLD\".charAt(Math.floor(move / 3));\n\n    switch (move % 3) {\n      case 1:\n        sequence += \"2\";\n        break;\n\n      case 2:\n        sequence += \"'\";\n        break;\n\n      default:\n    }\n  });\n\n  // Trim extra spaces.\n  return sequence.trim();\n};\n","import {\n  getIndexFromPermutation,\n  getPermutationFromIndex,\n  getIndexFromOrientation,\n  getParity,\n} from \"app/common/cube/libs/coordinates\";\n\nimport {\n  MoveTable,\n  createEdgePermutationTable,\n  createCornerPermutationTable,\n  createEdgeOrientationTable,\n  createCornerOrientationTable,\n} from \"app/common/cube/libs/move-table\";\n\nimport Search, { SearchSolution } from \"app/common/cube/libs/search\";\n\nimport { fiveSideMoves } from \"app/common/cube/libs/cube\";\n\n// In phase two, only quarter moves of U and D and double turns of\n// all the other faces are allowed, in order to keep the cube in\n// the phase two group G1.\nconst phaseTwoMoves = [10, 4, 13, 6, 7, 8, 15, 16, 17];\n\n// The following tables are being used in both phases.\nlet parity: MoveTable;\nlet URFToDLF: MoveTable;\nlet slice: MoveTable;\nlet merge: number[][];\n\nconst phaseTwoSearch = new Search(() => {\n  // In order to start phase two, we need to know the positions\n  // in which the pieces landed after solving the cube into G1.\n  // Since returning to the cubie level to perform the solution\n  // would be slow, we use two helper tables in phase one which\n  // later are merged into the final phase two coordinate.\n  const getMergeCoord = (x: number, y: number) => {\n    const a = getPermutationFromIndex(x, [0, 1, 2], 12);\n    const b = getPermutationFromIndex(y, [3, 4, 5], 12);\n\n    for (let i = 0; i < 8; i += 1) {\n      if (a[i] !== -1) {\n        if (b[i] !== -1) {\n          return -1;\n        }\n        b[i] = a[i];\n      }\n    }\n\n    return getIndexFromPermutation(b, [0, 1, 2, 3, 4, 5]);\n  };\n\n  merge = [];\n\n  // Due to the sorted nature of our coordinate definitions, the\n  // index of both the coordinates will be less than 336 when phase\n  // one is finished. This allows for a pretty small merging table.\n  for (let i = 0; i < 336; i += 1) {\n    merge.push([]);\n\n    for (let j = 0; j < 336; j += 1) {\n      merge[i][j] = getMergeCoord(i, j);\n    }\n  }\n\n  return {\n    moveTables: [\n      // The permutation of the slice pices, which already\n      // are in the correct positions on the cube.\n      new MoveTable({\n        name: \"slicePermutation\",\n        size: 24,\n        table: slice.table,\n      }),\n\n      parity,\n      URFToDLF,\n\n      createEdgePermutationTable({\n        name: \"URToDF\",\n        size: 20160,\n        moves: phaseTwoMoves,\n        affected: [0, 1, 2, 3, 4, 5],\n      }),\n    ],\n\n    pruningTables: [\n      [\"slicePermutation\", \"parity\", \"URFToDLF\"],\n      [\"slicePermutation\", \"parity\", \"URToDF\"],\n    ],\n  };\n}, phaseTwoMoves);\n\nclass TwoPhaseSearch extends Search {\n  maxDepth: number;\n  solution: number[];\n\n  constructor(...args: ConstructorParameters<typeof Search>) {\n    super(...args);\n\n    this.maxDepth = 40;\n    this.solution = [];\n  }\n\n  handleSolution(\n    solution: number[],\n    indexes: number[]\n  ): SearchSolution | false {\n    const lastMove = solution.slice(-1)[0];\n\n    // We do not allow solutions which end in a phase two move, as we then\n    // would end up duplicating work.\n    if (\n      lastMove % 2 === 0 &&\n      Math.floor(lastMove / 3) === 6 &&\n      Math.floor(lastMove / 3) === 15\n    ) {\n      return false;\n    }\n\n    const phaseTwoSolution = phaseTwoSearch.solve({\n      indexes: [\n        indexes[3],\n        indexes[4],\n        indexes[5],\n        merge[indexes[6]][indexes[7]],\n      ],\n      maxDepth: this.maxDepth - solution.length,\n      lastMove,\n      format: false,\n    });\n\n    if (phaseTwoSolution) {\n      this.solution = solution.concat(phaseTwoSolution.solution);\n\n      if (this.maxDepth <= this.settings.maxDepth) {\n        return {\n          solution: this.solution,\n          indexes,\n        };\n      }\n\n      this.maxDepth = this.solution.length - 1;\n    }\n\n    return false;\n  }\n}\n\nexport const FiveSideSearch = new TwoPhaseSearch(() => {\n  // The parity move table is so small that we inline it. It\n  // describes the parity of both the edge and corner pieces,\n  // which must be equal for the cube to be solvable. The\n  // coordinate is included in both phases, but only used\n  // in phase two.\n  parity = new MoveTable({\n    name: \"parity\",\n\n    size: 2,\n\n    table: [\n      [1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1],\n      [0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0],\n    ],\n  });\n\n  URFToDLF = createCornerPermutationTable({\n    name: \"URFToDLF\",\n    affected: [0, 1, 2, 3, 4, 5],\n  });\n\n  // This table is not used directly. This coordinate modulo 24 gives the\n  // permutation of the subarray containing the UD-slice pieces, while this\n  // coordinate divided by 24 gives the position of the UD-slice pieces.\n  // Two smaller move tables are created using this table, one to solve the\n  // position of the UD-slice pieces in phase one, and one to solve the\n  // pieces in phase two. Due to the reduced move set in phase two, the pruning\n  // table for this coordinate is smaller than it would normally be.\n  slice = createEdgePermutationTable({\n    name: \"slice\",\n    affected: [8, 9, 10, 11],\n    reversed: true,\n  });\n\n  // Initialize phase two, since it now is guaranteed that the\n  // heper move tables have finished generating.\n  phaseTwoSearch.initialize();\n\n  return {\n    moveTables: [\n      new MoveTable({\n        // The position of the slice edges. When this coordinate is\n        // solved, the UD-slice pieces are in the UD-slice, but they\n        // are not necessarily permuted.\n        name: \"slicePosition\",\n        size: 495,\n        table: slice.table,\n        doMove: (table, index, move) =>\n          Math.floor(table[index * 24][move] / 24),\n      }),\n\n      createCornerOrientationTable({\n        name: \"twist\",\n        affected: [0, 1, 2, 3, 4, 5, 6, 7],\n      }),\n\n      createEdgeOrientationTable({\n        name: \"flip\",\n        affected: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],\n      }),\n\n      slice,\n      parity,\n      URFToDLF,\n\n      createEdgePermutationTable({\n        name: \"URToUL\",\n        affected: [0, 1, 2],\n      }),\n\n      createEdgePermutationTable({\n        name: \"UBToDF\",\n        affected: [3, 4, 5],\n      }),\n    ],\n\n    pruningTables: [\n      [\"slicePosition\", \"flip\"],\n      [\"slicePosition\", \"twist\"],\n    ],\n  };\n}, fiveSideMoves);\n\nconst FiveSideSolver = (\n  scramble: string | number[],\n  maxDepth = 40\n): false | string => {\n  if (Array.isArray(scramble)) {\n    return FiveSideSearch.solve({\n      indexes: scramble,\n      maxDepth,\n    });\n  }\n\n  return FiveSideSearch.solve({\n    scramble,\n    maxDepth,\n  });\n};\n\nexport default FiveSideSolver;\n\nexport const solveCoordinates = (\n  eo: number[],\n  ep: number[],\n  co: number[],\n  cp: number[]\n): ReturnType<typeof FiveSideSolver> =>\n  FiveSideSolver([\n    Math.floor(getIndexFromPermutation(ep, [8, 9, 10, 11], true) / 24),\n    getIndexFromOrientation(co, 3),\n    getIndexFromOrientation(eo, 2),\n    getIndexFromPermutation(ep, [8, 9, 10, 11], true),\n    getParity(cp),\n    getIndexFromPermutation(cp, [0, 1, 2, 3, 4, 5]),\n    getIndexFromPermutation(ep, [0, 1, 2]),\n    getIndexFromPermutation(ep, [3, 4, 5]),\n  ]);\n","import { parseAlgorithm } from \"./algorithms\";\nimport { rotateParts } from \"./tools\";\n\nexport const Edges = {\n  UR: 0,\n  UF: 1,\n  UL: 2,\n  UB: 3,\n  DR: 4,\n  DF: 5,\n  DL: 6,\n  DB: 7,\n  FR: 8,\n  FL: 9,\n  BL: 10,\n  BR: 11,\n};\n\nexport const Corners = {\n  URF: 0,\n  UFL: 1,\n  ULB: 2,\n  UBR: 3,\n  DFR: 4,\n  DLF: 5,\n  DBL: 6,\n  DBR: 7,\n};\n\n/**\n * We define moves as the four pieces which are\n * rotated in a circular fashion.\n */\nconst edgeMoves = [\n  [1, 8, 5, 9],\n  [0, 11, 4, 8],\n  [1, 2, 3, 0],\n  [3, 10, 7, 11],\n  [2, 9, 6, 10],\n  [5, 4, 7, 6],\n];\n\n/**\n * Corner moves are defined in the same way as\n * the edge moves are defined.\n */\nconst cornerMoves = [\n  [1, 0, 4, 5],\n  [0, 3, 7, 4],\n  [0, 1, 2, 3],\n  [3, 2, 6, 7],\n  [2, 1, 5, 6],\n  [5, 4, 7, 6],\n];\n\n/**\n * Helper function to perform a corner or edge permutation move\n * to the given permutation vector.\n */\nconst permutationMove = (\n  pieces: number[],\n  moveIndex: number,\n  moves: number[][]\n) => {\n  let updated = pieces;\n  const move = moves[Math.floor(moveIndex / 3)];\n  const pow = moveIndex % 3;\n\n  for (let i = 0; i <= pow; i += 1) {\n    updated = rotateParts(updated, move);\n  }\n\n  return updated;\n};\n\n/**\n * Perform a move to an edge permutaion vector.\n */\nexport const edgePermutationMove = (\n  pieces: number[],\n  moveIndex: number\n): number[] => permutationMove(pieces, moveIndex, edgeMoves);\n\n/**\n * Perform a move to a corner permuttaion vector.\n */\nexport const cornerPermutationMove = (\n  pieces: number[],\n  moveIndex: number\n): number[] => permutationMove(pieces, moveIndex, cornerMoves);\n\n/**\n * Perform a move to an edge orientation vector.\n */\nexport const edgeOrientationMove = (\n  pieces: number[],\n  moveIndex: number\n): number[] => {\n  const moveNumber = Math.floor(moveIndex / 3);\n  const move = edgeMoves[moveNumber];\n  const pow = moveIndex % 3;\n\n  const updatedPieces = edgePermutationMove(pieces, moveIndex);\n\n  // Only quarter moves of the F and B faces affect the edge orientation.\n  if ((moveNumber === 0 || moveNumber === 3) && pow % 2 === 0) {\n    for (let i = 0; i < 4; i += 1) {\n      updatedPieces[move[i]] = (updatedPieces[move[i]] + 1) % 2;\n    }\n  }\n\n  return updatedPieces;\n};\n\n/**\n * Perform a move to a corner orientation vector.\n */\nexport const cornerOrientationMove = (\n  pieces: number[],\n  moveIndex: number\n): number[] => {\n  const moveNumber = Math.floor(moveIndex / 3);\n  const move = cornerMoves[moveNumber];\n  const pow = moveIndex % 3;\n\n  const updatedPieces = cornerPermutationMove(pieces, moveIndex);\n\n  // Only quarter moves of any slice but the U and D slices\n  // affect the corner orientation.\n  if (moveNumber !== 2 && moveNumber !== 5 && pow % 2 === 0) {\n    for (let i = 0; i < 4; i += 1) {\n      updatedPieces[move[i]] = (updatedPieces[move[i]] + ((i + 1) % 2) + 1) % 3;\n    }\n  }\n\n  return updatedPieces;\n};\n\n// The identity cube.\nexport const identity = {\n  ep: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],\n  eo: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n  cp: [0, 1, 2, 3, 4, 5, 6, 7],\n  co: [0, 0, 0, 0, 0, 0, 0, 0],\n};\n\nexport interface CubeIndexes {\n  ep: number[];\n  eo: number[];\n  cp: number[];\n  co: number[];\n}\n\n/**\n * Performs an algorithm to a cube on the cubie level.\n */\nexport const doAlgorithm = (\n  algorithm: string,\n  cube = identity\n): CubeIndexes => {\n  let ep = cube.ep.slice();\n  let eo = cube.eo.slice();\n  let cp = cube.cp.slice();\n  let co = cube.co.slice();\n\n  parseAlgorithm(algorithm).forEach((move) => {\n    ep = edgePermutationMove(ep, move);\n    eo = edgeOrientationMove(eo, move);\n    cp = cornerPermutationMove(cp, move);\n    co = cornerOrientationMove(co, move);\n  });\n\n  return {\n    ep,\n    eo,\n    cp,\n    co,\n  };\n};\n\n/**\n * All the moves which can be performed on a cube.\n */\nexport const allMoves = [\n  0, //f\n  1,\n  2,\n  3, //r\n  4,\n  5,\n  6, //u\n  7,\n  8,\n  9, //b\n  10,\n  11,\n  12, //l\n  13,\n  14,\n  15, //d\n  16,\n  17,\n];\n\nexport const fiveSideMoves = [\n  3,\n  4,\n  5,\n  6,\n  7,\n  8,\n  9,\n  10,\n  11,\n  12,\n  13,\n  14,\n  15,\n  16,\n  17,\n];\n","import {\n  getPermutationFromIndex,\n  getIndexFromPermutation,\n  getOrientationFromIndex,\n  getIndexFromOrientation,\n} from \"./coordinates\";\n\nimport {\n  edgePermutationMove,\n  cornerPermutationMove,\n  edgeOrientationMove,\n  cornerOrientationMove,\n  allMoves,\n} from \"./cube\";\n\nimport { factorial } from \"./tools\";\n\n/**\n * Create a function which performs a move on a coordinate.\n */\nconst createMoveHandler = (\n  getVector: GetVectorCallback,\n  cubieMove: CubieMoveCallback,\n  getIndex: GetIndexCallback\n) => (index: number, move: number) => {\n  let vector = getVector(index);\n  vector = cubieMove(vector, move);\n  return getIndex(vector);\n};\n\ntype GetVectorCallback = (index: number) => number[];\ntype CubieMoveCallback = (pieces: number[], moveIndex: number) => number[];\ntype GetIndexCallback = (pieces: number[]) => number;\n\ninterface BaseMoveTableSettings {\n  name: string;\n  size: number;\n  defaultIndex?: number;\n  solvedIndexes?: number[];\n  doMove?: (table: number[][], index: number, move: number) => number;\n}\n\ninterface MoveTableSettingsWithTable extends BaseMoveTableSettings {\n  table: number[][];\n}\n\nexport interface MoveTableSettingsWithoutTable extends BaseMoveTableSettings {\n  moves?: number[];\n  getVector: GetVectorCallback;\n  cubieMove: (pieces: number[], moveIndex: number) => number[];\n  getIndex: GetIndexCallback;\n}\n\nexport type MoveTableSettings =\n  | MoveTableSettingsWithTable\n  | MoveTableSettingsWithoutTable;\n\nexport class MoveTable {\n  name: string;\n  size: number;\n  defaultIndex: number;\n  solvedIndexes: number[];\n  table: number[][];\n\n  constructor(settings: MoveTableSettings) {\n    // A name must be provided if the generic solver is being used, as\n    // we use them to create the pruning tables.\n    this.name = settings.name;\n\n    // Some tables in the Kociemba solver define their own size, as\n    // they are a subset of another already generated helper table.\n    this.size = settings.size;\n\n    this.defaultIndex = settings.defaultIndex || 0;\n    this.solvedIndexes = settings.solvedIndexes || [this.defaultIndex];\n\n    // We allow defining a custom function that returns the updated\n    // index. This is useful for helper tables which are subsets\n    // of already generated tables.\n    const doMove = settings.doMove;\n    if (doMove) {\n      this.doMove = (index, move) => doMove(this.table, index, move);\n    }\n\n    if (\"table\" in settings) {\n      this.table = settings.table;\n\n      // If a pre-generated table is provide, do not generate another one.\n      return;\n    }\n\n    const cubieMove = createMoveHandler(\n      settings.getVector,\n      settings.cubieMove,\n      settings.getIndex\n    );\n\n    this.table = this.createMoveTable(settings.size, cubieMove, settings.moves);\n  }\n\n  doMove(index: number, move: number): number {\n    return this.table[index][move];\n  }\n\n  createMoveTable(\n    size: number,\n    cubieMove: ReturnType<typeof createMoveHandler>,\n    moves = allMoves\n  ): number[][] {\n    const table: number[][] = [];\n\n    for (let i = 0; i < size; i += 1) {\n      table.push([]);\n    }\n\n    // Create a matrix which stores the result after\n    // applying a move to a coordinate.\n    for (let i = 0; i < size; i += 1) {\n      for (let j = 0; j < moves.length; j += 1) {\n        const move = moves[j];\n\n        if (!table[i][move]) {\n          // Assign both the value and its inverse at once\n          // to avoid exess computing on the cubie level.\n          const result = cubieMove(i, move);\n          const inverse = move - 2 * (move % 3) + 2;\n          table[i][move] = result;\n          table[result][inverse] = i;\n        }\n      }\n    }\n\n    return table;\n  }\n}\n\nexport interface PermutationTableSettings {\n  name: string;\n  moves?: number[];\n  affected: number[];\n  reversed?: boolean;\n  size?: number;\n}\n\nexport const createCornerPermutationTable = (\n  settings: PermutationTableSettings\n): MoveTable =>\n  new MoveTable({\n    name: settings.name,\n    moves: settings.moves,\n    defaultIndex: getIndexFromPermutation(\n      [0, 1, 2, 3, 4, 5, 6, 7],\n      settings.affected,\n      settings.reversed\n    ),\n    size:\n      settings.size || factorial(8) / factorial(8 - settings.affected.length),\n    getVector: (index) =>\n      getPermutationFromIndex(\n        index,\n        settings.affected.slice(),\n        8,\n        settings.reversed\n      ),\n    cubieMove: cornerPermutationMove,\n    getIndex: (pieces) =>\n      getIndexFromPermutation(pieces, settings.affected, settings.reversed),\n  });\n\nexport const createEdgePermutationTable = (\n  settings: PermutationTableSettings\n): MoveTable =>\n  new MoveTable({\n    name: settings.name,\n    moves: settings.moves,\n    defaultIndex: getIndexFromPermutation(\n      [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],\n      settings.affected,\n      settings.reversed\n    ),\n    size:\n      settings.size || factorial(12) / factorial(12 - settings.affected.length),\n    getVector: (index) =>\n      getPermutationFromIndex(\n        index,\n        settings.affected.slice(),\n        12,\n        settings.reversed\n      ),\n    cubieMove: edgePermutationMove,\n    getIndex: (pieces) =>\n      getIndexFromPermutation(pieces, settings.affected, settings.reversed),\n  });\n\nconst getCorrectOrientations = (\n  affected: number[],\n  numPieces: number,\n  numStates: number\n) => {\n  const indexes = [];\n\n  const size = numStates ** (numPieces - 1);\n\n  const target = numStates ** (numPieces - affected.length - 1);\n\n  for (let i = 0; i < size && indexes.length < target; i += 1) {\n    const orientation = getOrientationFromIndex(i, numPieces, numStates);\n\n    if (affected.every((piece) => orientation[piece] === 0)) {\n      indexes.push(i);\n    }\n  }\n\n  return indexes;\n};\n\nexport interface OrientationTableSettings {\n  name: string;\n  affected: number[];\n}\n\nexport const createEdgeOrientationTable = (\n  settings: OrientationTableSettings\n): MoveTable =>\n  new MoveTable({\n    name: settings.name,\n    size: 2048,\n    solvedIndexes: getCorrectOrientations(settings.affected, 12, 2),\n    getVector: (index) => getOrientationFromIndex(index, 12, 2),\n    cubieMove: edgeOrientationMove,\n    getIndex: (pieces) => getIndexFromOrientation(pieces, 2),\n  });\n\nexport const createCornerOrientationTable = (\n  settings: OrientationTableSettings\n): MoveTable =>\n  new MoveTable({\n    name: settings.name,\n    size: 2187,\n    solvedIndexes: getCorrectOrientations(settings.affected, 8, 3),\n    getVector: (index) => getOrientationFromIndex(index, 8, 3),\n    cubieMove: cornerOrientationMove,\n    getIndex: (pieces) => getIndexFromOrientation(pieces, 3),\n  });\n","import { cartesian } from \"./tools\";\nimport { MoveTable } from \"./move-table\";\n\n/**\n * A pruning table gives a lower bound on the number of moves\n * required to reach a target state.\n */\nclass PruningTable {\n  table: number[];\n  constructor(moveTables: MoveTable[], moves: number[]) {\n    this.table = [];\n    this.computePruningTable(moveTables, moves);\n  }\n\n  setPruningValue(index: number, value: number): void {\n    this.table[index >> 3] ^= (0xf ^ value) << ((index & 7) << 2);\n  }\n\n  getPruningValue(index: number): number {\n    return (this.table[index >> 3] >> ((index & 7) << 2)) & 0xf;\n  }\n\n  computePruningTable(moveTables: MoveTable[], moves: number[]): void {\n    const size = moveTables.reduce((acc, obj) => acc * obj.size, 1);\n\n    this.table.length = 0;\n\n    for (let i = 0; i < (size + 7) >> 3; i += 1) {\n      this.table.push(-1);\n    }\n\n    let depth = 0;\n    let done = 0;\n\n    const powers = [1];\n\n    for (let i = 1; i < moveTables.length; i += 1) {\n      powers.push(moveTables[i - 1].size * powers[i - 1]);\n    }\n\n    const permutations = cartesian(\n      moveTables.map((data) => data.solvedIndexes)\n    );\n\n    for (let i = 0; i < permutations.length; i += 1) {\n      let index = 0;\n\n      for (let j = 0; j < permutations[i].length; j += 1) {\n        index += powers[j] * permutations[i][j];\n      }\n\n      this.setPruningValue(index, 0);\n\n      done += 1;\n    }\n\n    // We generate the table using a BFS. Depth 0 contains all positions which\n    // are solved, and we loop through the correct indexes and apply all 18 moves\n    // to the correct states. Then we visit all positions at depth 2, and apply\n    // the 18 moves, and so on.\n    while (done !== size) {\n      // When half the table is generated, we switch to a backward search\n      // where we apply the 18 moves to all empty entries. If the result\n      // is a position which corresponds to the previous depth, we set the\n      // index to the current depth.\n      const inverse = done > size / 2;\n      const find = inverse ? 0xf : depth;\n      const check = inverse ? depth : 0xf;\n\n      depth += 1;\n\n      for (let index = 0; index < size; index += 1) {\n        if (this.getPruningValue(index) === find) {\n          for (let moveIndex = 0; moveIndex < moves.length; moveIndex += 1) {\n            const move = moves[moveIndex];\n\n            let currentIndex = index;\n            let position = 0;\n\n            for (let i = powers.length - 1; i >= 0; i -= 1) {\n              position +=\n                powers[i] *\n                moveTables[i].doMove(\n                  Math.floor(currentIndex / powers[i]),\n                  move\n                );\n              currentIndex %= powers[i];\n            }\n\n            if (this.getPruningValue(position) === check) {\n              done += 1;\n\n              if (inverse) {\n                this.setPruningValue(index, depth);\n                break;\n              }\n\n              this.setPruningValue(position, depth);\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\nexport default PruningTable;\n","import { parseAlgorithm, formatAlgorithm, invertAlgorithm } from \"./algorithms\";\nimport PruningTable from \"./pruning-table\";\nimport { allMoves } from \"./cube\";\nimport { MoveTable } from \"./move-table\";\n\nexport interface CreateTableCallback {\n  (): {\n    moveTables: MoveTable[];\n    pruningTables: string[][];\n  };\n}\n\nexport interface SearchSolution {\n  indexes: number[];\n  solution: number[]; // array of move indexes\n}\n\ninterface BaseSearchSettings {\n  scramble?: string;\n  maxDepth?: number;\n  lastMove?: number;\n  format?: boolean;\n  indexes?: number[];\n}\n\nexport interface SearchSettingsWithoutFormat extends BaseSearchSettings {\n  format: false;\n}\n\nexport interface SearchSettingsWithFormat extends BaseSearchSettings {\n  format?: true;\n}\n\nexport type SearchSettings =\n  | SearchSettingsWithFormat\n  | SearchSettingsWithoutFormat;\n\ntype DefaultedSearchSettings = Required<\n  Pick<SearchSettings, \"maxDepth\" | \"lastMove\" | \"format\">\n> &\n  SearchSettings;\n\nclass Search {\n  moves: number[];\n  initialized!: boolean;\n  moveTables!: MoveTable[];\n  settings!: DefaultedSearchSettings;\n  pruningTables!: Array<{\n    pruningTable: PruningTable;\n    moveTableIndexes: number[];\n  }>;\n  createTables: CreateTableCallback;\n\n  constructor(createTables: CreateTableCallback, moves = allMoves) {\n    this.createTables = createTables;\n    this.moves = moves;\n  }\n\n  initialize(): void {\n    if (this.initialized) {\n      return;\n    }\n\n    this.initialized = true;\n\n    const { moveTables, pruningTables } = this.createTables();\n\n    this.moveTables = moveTables;\n\n    this.pruningTables = [];\n\n    pruningTables.forEach((moveTableNames) => {\n      const moveTableIndexes = moveTableNames.map((name) =>\n        this.moveTables.map((table) => table.name).indexOf(name)\n      );\n\n      moveTableIndexes.sort(\n        (a, b) => this.moveTables[a].size - this.moveTables[b].size\n      );\n\n      const mappedTables: MoveTable[] = [];\n\n      moveTableIndexes.forEach((i) => mappedTables.push(this.moveTables[i]));\n\n      const pruningTable = new PruningTable(mappedTables, this.moves);\n\n      this.pruningTables.push({\n        pruningTable,\n        moveTableIndexes,\n      });\n    });\n  }\n\n  handleSolution(\n    solution: number[],\n    indexes: number[]\n  ): SearchSolution | false {\n    return {\n      solution,\n      indexes,\n    };\n  }\n\n  search(\n    indexes: number[],\n    depth: number,\n    lastMove: number,\n    solution: number[]\n  ): SearchSolution | false {\n    let minimumDistance = 0;\n\n    for (let i = 0; i < this.pruningTables.length; i += 1) {\n      let index = indexes[this.pruningTables[i].moveTableIndexes[0]];\n      let power = 1;\n\n      for (\n        let j = 1;\n        j < this.pruningTables[i].moveTableIndexes.length;\n        j += 1\n      ) {\n        power *= this.moveTables[this.pruningTables[i].moveTableIndexes[j - 1]]\n          .size;\n        index += indexes[this.pruningTables[i].moveTableIndexes[j]] * power;\n      }\n\n      const distance = this.pruningTables[i].pruningTable.getPruningValue(\n        index\n      );\n\n      if (distance > depth) {\n        return false;\n      }\n\n      // The true minimum distance to the solved indexes is\n      // given by the pruning table with the largest distance.\n      if (distance > minimumDistance) {\n        minimumDistance = distance;\n      }\n    }\n\n    if (minimumDistance === 0) {\n      return this.handleSolution(solution, indexes);\n    }\n\n    if (depth > 0) {\n      for (let i = 0; i < this.moves.length; i += 1) {\n        const move = this.moves[i];\n\n        if (\n          Math.floor(move / 3) !== Math.floor(lastMove / 3) &&\n          Math.floor(move / 3) !== Math.floor(lastMove / 3) - 3\n        ) {\n          const updatedIndexes = [];\n\n          for (let j = 0; j < indexes.length; j += 1) {\n            updatedIndexes.push(this.moveTables[j].doMove(indexes[j], move));\n          }\n\n          const result = this.search(\n            updatedIndexes,\n            depth - 1,\n            move,\n            solution.concat([move])\n          );\n\n          if (result) {\n            return result;\n          }\n        }\n      }\n    }\n\n    return false;\n  }\n\n  solve(settings: SearchSettingsWithFormat): string | false;\n  solve(settings: SearchSettingsWithoutFormat): SearchSolution | false;\n  solve(settings: SearchSettings): SearchSolution | string | false {\n    this.initialize();\n\n    this.settings = {\n      maxDepth: 22, // For the Kociemba solver.\n      lastMove: 0,\n      format: true,\n      ...settings,\n    };\n\n    const indexes = this.settings.indexes || [];\n\n    let solutionRotation;\n\n    if (this.settings.scramble) {\n      const [moves, totalRotation] = parseAlgorithm(\n        this.settings.scramble,\n        true\n      );\n\n      if (totalRotation.length > 0) {\n        solutionRotation = invertAlgorithm(totalRotation.join(\" \"));\n      }\n\n      for (let i = 0; i < this.moveTables.length; i += 1) {\n        indexes.push(this.moveTables[i].defaultIndex);\n      }\n\n      moves.forEach((move) => {\n        for (let i = 0; i < indexes.length; i += 1) {\n          indexes[i] = this.moveTables[i].doMove(indexes[i], move);\n        }\n      });\n    }\n\n    for (let depth = 0; depth <= this.settings.maxDepth; depth += 1) {\n      const solution = this.search(indexes, depth, this.settings.lastMove, []);\n\n      if (solution) {\n        if (this.settings.format) {\n          const formatted = formatAlgorithm(solution.solution);\n\n          if (solutionRotation) {\n            // If we have rotations in the scramble, apply them to the solution\n            // and then parse again to remove the rotations. This results in a\n            // solution that can be applied from the result scramble orientation.\n            return formatAlgorithm(\n              parseAlgorithm(`${solutionRotation} ${formatted}`)\n            );\n          }\n\n          return formatted;\n        }\n\n        return solution;\n      }\n    }\n\n    return false;\n  }\n}\n\nexport default Search;\n","import {\n  getPermutationFromIndex,\n  getOrientationFromIndex,\n  getParity,\n} from \"app/common/cube/libs/coordinates\";\n\nimport {\n  getRandomInt,\n  factorial,\n  rotateParts,\n} from \"app/common/cube/libs/tools\";\n\nimport { solveCoordinates } from \"app/common/cube/solvers/five-side-solver\";\n\nconst UPPER_FACE_POSITIONS = [0, 1, 2, 3];\n\n/**\n * Returns an orientation vector where all pieces\n * are solved, except for the given enabled pieces.\n */\nconst getOrientationFromEnabled = (\n  enabled: number[],\n  flipCount: number,\n  size: number\n) => {\n  const pieces = getOrientationFromIndex(\n    getRandomInt(0, flipCount ** (enabled.length - 1)),\n    enabled.length,\n    flipCount\n  );\n\n  const orientation = Array(size).fill(0);\n\n  enabled.forEach((piece, i) => {\n    orientation[piece] = pieces[i];\n  });\n\n  return orientation;\n};\n\n/**\n * Returns a permutation vector where all pieces are\n * solved, except for the given enabled pieces.\n */\nconst getPermutationFromEnabled = (enabled: number[], size: number) => {\n  const pieces = getPermutationFromIndex(\n    getRandomInt(0, factorial(enabled.length)),\n    enabled.slice(0),\n    enabled.length\n  );\n\n  const permutation = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11].slice(0, size);\n\n  enabled.forEach((piece, i) => {\n    permutation[piece] = pieces[i];\n  });\n\n  return permutation;\n};\n\nexport const adjustUpperFace = (\n  pieces: number[],\n  amount?: number\n): number[] => {\n  amount = amount || getRandomInt(0, 4);\n\n  for (let i = 0; i < amount; i += 1) {\n    pieces = rotateParts(pieces, UPPER_FACE_POSITIONS);\n  }\n\n  return pieces;\n};\n\n/**\n * Generates a random scramble where all pieces are solved, except\n * for the provided edges and corners, which will be scrambled randomly.\n */\nexport const getScrambleForPieces = (\n  permutationEdges: number[],\n  permutationCorners: number[],\n  orientationEdges = permutationEdges,\n  orientationCorners = permutationCorners,\n  adjustEdges = false,\n  adjustCorners = false\n): string | false => {\n  let eo;\n  let ep;\n  let co;\n  let cp;\n\n  do {\n    eo = getOrientationFromEnabled(orientationEdges, 2, 12);\n\n    ep = getPermutationFromEnabled(permutationEdges, 12);\n\n    if (adjustEdges) {\n      ep = adjustUpperFace(ep);\n    }\n\n    co = getOrientationFromEnabled(orientationCorners, 3, 8);\n\n    cp = getPermutationFromEnabled(permutationCorners, 8);\n\n    if (adjustCorners) {\n      cp = adjustUpperFace(cp);\n    }\n  } while (getParity(ep) !== getParity(cp));\n\n  return solveCoordinates(eo, ep, co, cp);\n};\n\nexport default getScrambleForPieces;\n","import { chunkReducer } from \"app/common/array-reducers\";\n\nconst moveMap: Record<string, number> = {\n  R: 0,\n  R2: 1,\n  \"R'\": 2,\n  D: 3,\n  D2: 4,\n  \"D'\": 5,\n  B: 6,\n  B2: 7,\n  \"B'\": 8,\n  L: 9,\n  L2: 10,\n  \"L'\": 11,\n  U: 12,\n  U2: 13,\n  \"U'\": 14,\n};\n\nexport function getGANEncoding(scramble: string): Uint8Array {\n  return new Uint8Array(\n    scramble\n      .split(\" \")\n      .map((move) => moveMap[move])\n      .reduce(chunkReducer(2), [])\n      .map((moves) => moves[0] * 16 + (moves[1] ?? 15))\n  );\n}\n","interface Reducer<T, K> {\n  (acc: T, curr: K): T;\n}\n\nexport const chunkReducer = <T>(\n  chunckSize: number\n): Reducer<Array<Array<T>>, T> => {\n  let currentChunk: Array<T>;\n  return (accumulator: Array<Array<T>>, currentValue: T) => {\n    if (!currentChunk || currentChunk.length === chunckSize) {\n      currentChunk = [];\n      accumulator.push(currentChunk);\n    }\n    currentChunk.push(currentValue);\n    return accumulator;\n  };\n};\n","import {\n  createEdgePermutationTable,\n  createEdgeOrientationTable,\n} from \"app/common/cube/libs/move-table\";\n\nimport Search from \"app/common/cube/libs/search\";\n\nimport { fiveSideMoves, Edges } from \"app/common/cube/libs/cube\";\n\nexport const CrossSearch = new Search(\n  () => ({\n    moveTables: [\n      createEdgePermutationTable({\n        name: \"EdgePermutation\",\n        affected: [Edges.UB, Edges.UF, Edges.UL, Edges.UR],\n      }),\n\n      createEdgeOrientationTable({\n        name: \"EdgeOrientation\",\n        affected: [Edges.UB, Edges.UF, Edges.UL, Edges.UR],\n      }),\n    ],\n\n    pruningTables: [[\"EdgePermutation\"], [\"EdgeOrientation\"]],\n  }),\n  fiveSideMoves\n);\n\nexport const crossSolver = (scramble: string): string | false =>\n  CrossSearch.solve({ scramble });\n","import React from \"react\";\nimport Cube from \"cubejs\";\nimport CubePreviewCreator from \"cube-preview\";\n\nexport function createScramblePreview(scrambleCode: string): string {\n  const cube = new Cube();\n  cube.move(scrambleCode);\n  return new CubePreviewCreator().svgString(cube.asString());\n}\n\ninterface CubePreviewProps {\n  scrambleCode: string;\n}\n\nexport function CubePreview(props: CubePreviewProps): JSX.Element {\n  const svgString = createScramblePreview(props.scrambleCode);\n  return (\n    <div\n      style={{ width: \"50%\" }}\n      dangerouslySetInnerHTML={{ __html: svgString }}\n    ></div>\n  );\n}\n","import React, { useState } from \"react\";\nimport { connect } from \"react-redux\";\nimport {\n  Button,\n  Typography,\n  FormControl,\n  FormLabel,\n  RadioGroup,\n  FormControlLabel,\n  Radio,\n} from \"@material-ui/core\";\nimport { FormattedMessage } from \"react-intl\";\n\nimport { ApplicationState } from \"app/common/store\";\n\nimport { getRobotServer } from \"app/robot-widget/store/selectors\";\n\nimport { generateScramble } from \"app/common/cube/scramblers/full\";\nimport { generateOLLScramble } from \"app/common/cube/scramblers/oll\";\nimport { getGANEncoding } from \"app/common/cube/libs/gan-encoder\";\nimport { crossSolver } from \"app/common/cube/solvers/cross-solver\";\nimport { CubePreview } from \"app/cube-preview\";\nimport { generatePLLScramble } from \"app/common/cube/scramblers/pll\";\n\nconst SCRAMBLE_SERVICE_UUID = 0xfff0;\nconst SCRAMBLE_CHARACTERISTIC_UUID = 0xfff3;\n\ninterface ScrambleGeneratorProps {\n  robotServer: BluetoothRemoteGATTServer | null;\n}\n\ntype ScrambleType = \"full\" | \"f2l\" | \"oll\" | \"pll\";\n\nexport function ScrambleGenerator(props: ScrambleGeneratorProps): JSX.Element {\n  const [scrambleType, setScrambleType] = useState<ScrambleType>(\"full\");\n  const [scramble, setScramble] = useState<string | null>(null);\n  return (\n    <div className=\"flex-col items-start\">\n      <FormControl component=\"fieldset\">\n        <FormLabel component=\"legend\">Scramble Type</FormLabel>\n        <RadioGroup\n          row\n          aria-label=\"Scramble Type\"\n          name=\"scrambleType\"\n          value={scrambleType}\n          onChange={(e) =>\n            setScrambleType(e.currentTarget.value as ScrambleType)\n          }\n        >\n          <FormControlLabel value=\"full\" control={<Radio />} label=\"Full\" />\n          <FormControlLabel value=\"f2l\" control={<Radio />} label=\"F2L\" />\n          <FormControlLabel value=\"oll\" control={<Radio />} label=\"OLL\" />\n          <FormControlLabel value=\"pll\" control={<Radio />} label=\"PLL\" />\n        </RadioGroup>\n      </FormControl>\n      <Button\n        variant=\"contained\"\n        onClick={() => {\n          switch (scrambleType) {\n            case \"full\":\n              setScramble(generateScramble());\n              break;\n            case \"f2l\":\n              // faster to do a simple cross solve than a full solve\n              const scramble = generateScramble(19);\n              const solveCode = crossSolver(scramble);\n              if (solveCode) {\n                setScramble(`${scramble} ${solveCode}`);\n              }\n              break;\n            case \"oll\":\n              const ollScramble = generateOLLScramble();\n              if (ollScramble) {\n                setScramble(ollScramble);\n              }\n              break;\n            case \"pll\":\n              const pllScramble = generatePLLScramble();\n              if (pllScramble) {\n                setScramble(pllScramble);\n              }\n              break;\n          }\n        }}\n      >\n        <FormattedMessage id=\"scrambleGenerator.actions.generate\" />\n      </Button>\n      {scramble && (\n        <>\n          <Typography variant=\"body1\">{scramble}</Typography>\n          <CubePreview scrambleCode={scramble} />\n          <Button\n            variant=\"contained\"\n            disabled={!Boolean(props.robotServer)}\n            onClick={async () => {\n              try {\n                if (props.robotServer) {\n                  const scrambleService = await props.robotServer.getPrimaryService(\n                    SCRAMBLE_SERVICE_UUID\n                  );\n                  const scrambleExecuteCharacteristic = await scrambleService.getCharacteristic(\n                    SCRAMBLE_CHARACTERISTIC_UUID\n                  );\n\n                  await scrambleExecuteCharacteristic.writeValue(\n                    getGANEncoding(scramble)\n                  );\n                }\n              } catch (error) {\n                console.log(error);\n              }\n            }}\n          >\n            <FormattedMessage id=\"scrambleGenerator.actions.execute\" />\n          </Button>\n        </>\n      )}\n    </div>\n  );\n}\n\nexport const ScrambleGeneratorContainer = connect(\n  (state: ApplicationState) => ({\n    robotServer: getRobotServer(state),\n  })\n)(ScrambleGenerator);\n","import getScrambleForPieces from \"app/common/cube/libs/scramble-pieces\";\nimport { Edges, Corners } from \"app/common/cube/libs/cube\";\n\nexport const generateOLLScramble = (): string | false =>\n  getScrambleForPieces(\n    [Edges.DR, Edges.DF, Edges.DL, Edges.DB],\n\n    [Edges.DR, Edges.DF, Edges.DL, Edges.DB],\n\n    [Corners.DFR, Corners.DLF, Corners.DBL, Corners.DBR],\n\n    [Corners.DFR, Corners.DLF, Corners.DBL, Corners.DBR]\n  );\n","import { getScrambleForPieces } from \"app/common/cube/libs/scramble-pieces\";\nimport { Edges, Corners } from \"app/common/cube/libs/cube\";\n\nexport const generatePLLScramble = (): string | false =>\n  getScrambleForPieces(\n    [Edges.DR, Edges.DF, Edges.DL, Edges.DB],\n\n    [Corners.DFR, Corners.DLF, Corners.DBL, Corners.DBR],\n\n    [],\n\n    []\n  );\n","import React from \"react\";\nimport { AppBar, Toolbar, Typography } from \"@material-ui/core\";\nimport { FormattedMessage } from \"react-intl\";\n\nimport { RobotWidgetContainer } from \"app/robot-widget\";\nimport { ScrambleGeneratorContainer } from \"app/scramble-generator\";\n\nexport function MainScreen(): JSX.Element {\n  return (\n    <div className=\"flex-grow-1\">\n      <AppBar position=\"static\">\n        <Toolbar>\n          <Typography variant=\"h5\">\n            <FormattedMessage id=\"appTitle\" />\n          </Typography>\n          <div className=\"flex-row flex-grow-1 justify-end\">\n            <RobotWidgetContainer />\n          </div>\n        </Toolbar>\n      </AppBar>\n\n      <ScrambleGeneratorContainer />\n    </div>\n  );\n}\n","export function importAll<T = unknown>(\n  requireContext: __WebpackModuleApi.RequireContext\n): Record<string, T> {\n  const importCache: Record<string, T> = {};\n  requireContext\n    .keys()\n    .forEach(\n      (moduleKey: string) =>\n        (importCache[moduleKey] = requireContext(moduleKey))\n    );\n  return importCache;\n}\n","import pathParse from \"path-parse\";\nimport { importAll } from \"app/common/webpack\";\n\ninterface Translations {\n  [key: string]: string | Translations;\n}\n\n// import json translations\nconst translations = importAll<Translations>(\n  require.context(\"../\", true, /\\/translations\\/.*\\.json$/)\n);\n\nconst flattenTranslations = (trans: Translations, keys: string[] = []) =>\n  Object.keys(trans).reduce((acc, key) => {\n    const currentKeys = [...keys, key];\n    const value = trans[key];\n    if (typeof value === \"object\")\n      acc = { ...acc, ...flattenTranslations(value, currentKeys) };\n    else acc[currentKeys.join(\".\")] = value;\n    return acc;\n  }, {} as Record<string, string>);\n\n// merge translation files with the same locale\nconst messageMap = Object.keys(translations).reduce((acc, filepath) => {\n  const locale = pathParse(filepath).name;\n  acc[locale] = {\n    ...acc[locale],\n    ...flattenTranslations(translations[filepath]),\n  };\n  return acc;\n}, {} as Record<string, Record<string, string>>);\n\nexport const locale = navigator.language;\nexport const messages = messageMap[locale.toLowerCase()];\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === \"localhost\" ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === \"[::1]\" ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config): void {\n  if (process.env.NODE_ENV === \"production\" && \"serviceWorker\" in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener(\"load\", () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            \"This web app is being served cache-first by a service \" +\n              \"worker. To learn more, visit https://bit.ly/CRA-PWA\"\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === \"installed\") {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                \"New content is available and will be used when all \" +\n                  \"tabs for this page are closed. See https://bit.ly/CRA-PWA.\"\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log(\"Content is cached for offline use.\");\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error(\"Error during service worker registration:\", error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { \"Service-Worker\": \"script\" },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get(\"content-type\");\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf(\"javascript\") === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        \"No internet connection found. App is running in offline mode.\"\n      );\n    });\n}\n\nexport function unregister(): void {\n  if (\"serviceWorker\" in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { Provider } from \"react-redux\";\nimport { IntlProvider } from \"react-intl\";\n\nimport { MainScreen } from \"app/main-screen\";\nimport { createStore } from \"app/common/store\";\nimport { messages, locale } from \"translations\";\nimport { importAll } from \"app/common/webpack\";\n\nimport * as serviceWorker from \"./serviceWorker\";\n\n// execute any init scripts\nimportAll(require.context(\"./\", true, /\\/on-startup\\.(ts|tsx)$/));\n\n// include all global stylesheets\nimportAll(require.context(\"./\", true, /\\.css$/));\n\n// create store\nconst store = createStore();\n\nReactDOM.render(\n  <Provider store={store}>\n    <IntlProvider locale={locale} messages={messages}>\n      <MainScreen />\n    </IntlProvider>\n  </Provider>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.register();\n","import { PayloadAction } from \"@reduxjs/toolkit\";\n\nexport const payloadReducer = <S, P>(state: S, action: PayloadAction<P>): P => {\n  return action.payload;\n};\n\nexport const valueReducer = <T>(value: T): (() => T) => () => value;\n","import { createReducer, combineReducers } from \"@reduxjs/toolkit\";\nimport { registerRobot, unregisterRobot } from \"app/robot-widget/store/actions\";\nimport { RobotState } from \"app/robot-widget/store/types\";\nimport { payloadReducer, valueReducer } from \"app/common/store-reducers\";\n\nexport default combineReducers<RobotState>({\n  device: createReducer<RobotState[\"device\"]>(null, (builder) => {\n    builder.addCase(registerRobot, payloadReducer);\n    builder.addCase(unregisterRobot, valueReducer(null));\n  }),\n});\n","import { registerReducer } from \"app/common/store\";\n\nimport { RobotState } from \"app/robot-widget/store/types\";\nimport reducer from \"app/robot-widget/store/reducer\";\n\ndeclare module \"app/common/store\" {\n  interface ApplicationState {\n    robot: RobotState;\n  }\n}\n\nregisterReducer(\"robot\", reducer);\n","import { createAction } from \"@reduxjs/toolkit\";\n\nconst actionPrefix = \"setup\";\n\nexport const registerRobot = createAction<BluetoothDevice>(\n  `${actionPrefix}/register_robot`\n);\n\nexport const unregisterRobot = createAction(`${actionPrefix}/unregister_robot`);\n","import { Reducer } from \"redux\";\nimport { configureStore, EnhancedStore } from \"@reduxjs/toolkit\";\nimport createSagaMiddleware from \"redux-saga\";\nimport { SagaIterator } from \"redux-saga\";\nimport { call, spawn, delay } from \"redux-saga/effects\";\n\n// ApplicationState will be dynamically populated from on-startup.ts scripts\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface ApplicationState {}\nconst reducerRegistry: Record<string, Reducer> = {};\n\nexport function registerReducer<TKey extends keyof ApplicationState>(\n  key: TKey,\n  reducer: Reducer<ApplicationState[TKey]>\n): void {\n  reducerRegistry[key] = reducer;\n}\n\nexport type Saga = (...args: unknown[]) => SagaIterator;\nconst sagaRegistry: Saga[] = [];\n\nexport function registerSagas(sagas: Saga[]): void {\n  sagaRegistry.push(...sagas);\n}\n\nfunction* makeRestartable(saga: Saga) {\n  while (true) {\n    try {\n      yield call(saga);\n      console.error(\"Unexpected root saga termination\", saga);\n    } catch (e) {\n      console.error(\"Saga error, the saga will be restarted\", e);\n    }\n    yield delay(500);\n  }\n}\n\nfunction* rootSaga() {\n  yield sagaRegistry.map((saga) => spawn(makeRestartable, saga));\n}\n\nexport function createStore(): EnhancedStore {\n  const sagaMiddleware = createSagaMiddleware();\n  const store = configureStore({\n    reducer: reducerRegistry,\n    middleware: [sagaMiddleware],\n  });\n  sagaMiddleware.run(rootSaga);\n  return store;\n}\n"],"sourceRoot":""}